![1.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f87191af-4f11-4033-b065-98683cff3983/1.png)

## 🔸Swift의 모든 타입은 셋 중에 하나

원래 있거나 아니면 내가 만들었거나

![4.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/79e45214-c392-4745-a673-89a0fb224f12/4.png)

- 세상의 모든 것은 객체라고 생각
- 객체들 사이의 상호작용으로 프로그램 동작
- 객체는 하나의 역할을 수행하는 메서드와 데이터의 묶음

- 캡슐화(encapsulation)
- 상속(inheritance)
- 다형성(polymorphism)

## 🔸함수, 메서드, 클로저

- 앞서 배운것
    - 함수, 메서드, 클로저

- 이번에 배울 것
    - Swift는 객체지향 iOS 앱 개발을 광범위하게 지원한다.
    - 하지만, 객체지향 프로그램이라는 주제는 너무 크다.
    - 우리는 여기에서 객체지향 프로그래밍에 포함된 개본 개념을 살펴본 다음에 스위프트 앱 개발과 관련 개념을 살펴볼 것이다.

## 🔸객체란 무엇인가?

- **객체(또는 인스턴스)**는 소프트웨어 앱을 구축하는 블록으로 쉽게 사용하고 재사용할 수 있는 독립적인 기능 모듈이다.
- 작업을 수행하기 위한 객체나 인스턴스에서 접근되고 호출되는 **속성(property)**과 함께 **함수(method)**로 객체가 구성된다.
- 객체를 구성하는 데이터 변수와 함수를 포괄적으로 **클래스 멤버(class member)**라고 한다.

## 🔸클래스란 무엇인가?

- 빌딩이 건축되면 어떤 모양일지를 정의하는 청사진이나 건축가의 도면처럼 클래스는 객체가 생성될 때의 모습을 정의한다.
- 예를 들어, 메서드들이 하게 될 일이 무엇이며 어떤 프로퍼티들이 존재할지 등을 정의한다.

## 🔸클래스란 선언하기

- 객체를 인스턴스화하기 전에 먼저 객체에 대한 ‘청사진’인 클래스를 정의해야 한다.
- 여기서는 은행 계좌에 대한 클래스를 생성해본다.
- 새로운 Swift 클래스를 선언할 대 새롭게 만드는 클래스가 어떤 부모 클래스(parent class)에서 파생되었는지를 지정하고 클래스에 포함할 프로퍼티와 메서드를 정의한다.

![8.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/62221cce-9b65-4305-89f1-e7680b3ccc2f/8.png)

- **선언부의 프로퍼티** 부분은 이 클래스 내에 포함될 변수와 상수르 정의하며, swift에서 변수나 상수를 선언할 때와 동일한 방법을 선언한다.
- **인스턴스 메서드** & **타입 메서드** 부분은 이 클래스에서 호출되는 메서들과 클래스 인스턴스들을 정의한다.
- 본질적으로 이것들은 특정 작업을 수행하는 클래스 고유의 함수다.

![10.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a76e7730-3e5f-453d-82b4-66c1e6ae67ef/10.png)

## 🔸클래스에 인스턴스 프로퍼티 추가하기

![12.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/02f5cb64-fc1b-41ff-b6bc-9bd029eb4c7d/12.png)

- 객체지향 프로그래밍의 핵심 목적은 **데이터 캡슐화**라는 개념이다
- 데이터 캡슐화의 기본 개념은 클래스에 저장되고 접근될 수 있는 데이터는 오직 해당 클래스 내에 정의된 메서드만을 통해서 된다는 것이다.
- 클래스 내의 캡슐화된 데이터를 **프로퍼티** 또는 **인스턴스 변수**라고 한다.
- BankAccount 클래스의 인스턴스는 은행 계좌번호와 계좌에 남은 잔고 데이터를 저장하게 될 것이다.
- 프로퍼티는 Swift에서 변수나 상수를 선언할 때와 동일한 방법으로 선언된다.

## 🔸메서드 정의하기

![13.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/70eabd04-d055-4ae2-b6cf-3eaaa19825d4/13.png)

- diplayBalance 메서드는 인스턴스 메서드이므로 class 키워드가 앞에 붙지 않았다.

![14.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/66e254ae-b66b-4a64-b0c0-311ddb372647/14.png)

- BankAccount 클래스를 설계할 때 이 클래스에 저장할 수 있는 최대금액을 알기 위하여 클래스 자신의 타입메서드를 호출할 수 있따면 유용할 것이다.
- 이를 통해 앱이 클래스 인스턴스를 처음 생성하는 과정을 거치지 않아아도 BankAccount 클래스가 새로운 고객 정보를 저장할 수 있는지를 식별할 수 있게 해준다.
- 이 메서드의 이름을 getMaxBalance라고 할 것이다.

## 🔸클래스 인스턴스 선언하기 & 초기화하기

![15.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4ecc13b0-2ebf-4775-bc35-80b3120fb88e/15.png)

![16.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b895439c-eb98-404e-9663-630aa37c5fb2/16.png)

- 우리가 구조를 정의한 BankAccount 클래스를 가지고 어떤 작업을 하려면 클래스의 인스턴스를 생성해야 한다.
- 이 과정에서 첫번째 단계는 인스턴스에 대한 참조체를 저장할 변수를 선언하는 것이다.
- 다음 코드를 사용하면 우리의 BankAccount 클래스의 인스턴스가 생성될 것이며,  account1이라는 변수를 통해 접근할 수 있게 된다.

## 🔸클래스 인스턴스 초기화하기 & 소멸하기

![18.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5182fd8b-6a73-4b97-965a-527bfa84d684/18.png)

![19.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b5c83385-48a6-4a16-984c-25cbddec954f/19.png)

- 클래스는 생성하는 시점에 해야 할 초기화 작업이 있을 수 있다.
- 이 작업은 클래스의  **init 메서드** 안에 구현된다.
- BackAccount 클래스에서는 새로운 클래스 인스턴스가 생성될 때 계좌번호와 잔액을 초기화 할 것이다.
- 이를 위해 init 메서드를 작성한다.
    
    ![20.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/671a5dd7-4e1c-4f8b-8309-315a190c13cc/20.png)
    
- 반대로 ,swift 런타임 시스템에 의해 클래스 인스턴스가 없어지기 전에 해야 할 정리 작업은 클래스 안에 **소멸자**를 구현하면 할 수 있다.

## 🔸메서드 호출하기와 접근하기

- 우리는 지금까지
    - BankAccount라는 이름의 새로운 클래스를 만들었다.
    - 이 클래스에 은행 계좌번호와 잔액을 담기 위한 프로퍼티들을 선어하였고, 현재 잔액을 표시하기 위한 메서드도 선언하였다.
    - 새로운 클래스의 인스턴스를 생성하고 초기화하는데 필요한 작업도 확인했다.
- 이제 해야할 것은
    - 우리가 만든 클래스에 있는 인스턴스 메서드를 어떻게 호출하며
    - 프로퍼티에는 어떻게 접근하는지
    
    ![22.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa689488-4d1a-420a-aacd-9effe74e9364/22.png)
    
    - 점 표기법은 클래스 인스턴스 다음에 점을 찍고 그 뒤에 프로퍼티나 메서드 이름을 써서 인스턴스 변수에 접근하거나 인스턴스 메서드를 호출하게 된다.
    
    클래스인스턴스.프로퍼티명
    
    클래스인스턴스.인스턴스메서드()
    
    - Ex) accountBalance 인스턴스 변수의 현재 값 받으려면
    
          var balance1 = account1.accountBalance
    
    - 점표기법을 사용하면 인스턴스 프로퍼티에 값을 설정할 수 있다.
    
    account1.accountBalance = 6789.98 <- Float 값
    
    - 클래스 인스턴스의 메서드 호출할 때도 같은 방법 사용한다.
    - EX) BankAccount 클래스이 인스턴스에서 displayBalance 메서드를 호출하려면 다음과 같이한다.
        
        account.displayBalance()
        
    
    - 타입 메서드 역시 점 표깅법을 이용하여 출력된다.
    - 다만, 주의할 점은 클래스 인스턴스가 아니라 클래스에서 호출되어야 한다.
    
    클래스이름.타입메서드()
    
    - Ex) dkvdp tjsdjsgks xkdlq aptjem getMaxBalance를 호출한다면 BankAccount 클래스가 참조된다.
        
        var maxAllowed = BanckAccount.getMaxbalance()
        
    
    ## 🔸저장 프로퍼티와 연산 프로퍼티
    
- swift의 클래스 프로퍼티는 저장프로퍼티 & 연산으로 나뉜다.
- 저장 프로퍼티는 상수나 변수에 담기는 값이다.
- BankAccount 예제에서 계좌 이름과 번호 프로퍼티 모두 저장 프로퍼티다.
- 반면, 연산 프로퍼티는 프로퍼티에 값을 설정하거나 가져오는 시점에서 어떤 계산이나 로직에 따라 처리된 값이다.
- 연산 프로퍼티는 **getter**를 생성하고 선택적으로 **setter** 메서드를 생성하며 , 연산을 수행할 코드가 포함된다.
- 예를 들어, BankAccount 클래스에 은행 수수료를 뺀 현재 잔액을 담는 프로퍼티가 추가로 필요하다고 해보자
- 저장 프로퍼티를 이용하는 대신에 값에 대한 요청이 있을 때마다 계산되는 연산 프로퍼티를 이용하는 것이 더 좋겠다.

![25.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3b312fc9-90a9-4619-9e45-85b737a85ffb/25.png)

- 이제 BankAccount 클래스는 이렇게 수정된다.
- 현재의 잔액에서 수수료를 빼는 연산 프로퍼티를 반환하는 게터를 추가했다.

![26.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/75dfc71c-f446-4bb3-9cc8-932d84b4e72b/26.png)

- 선택 사항인 세터 역시 거의 같은 방법으로 선언할 수 있다.

![28.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3bf2f8bf-f678-44cd-ae53-88a7d725d25d/28.png)

![29.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6d22a72a-e096-477c-8c6a-f33ef39a7817/29.png)

- 새롭게 선언한 세터는 부동수수점 값을 매개변수로 받아서 수수료를 뺀 결과를 프로퍼티에 할당한다.
- 점 표시법을 이용하여 접근하는 저장 프로퍼티처럼 엿나 프로퍼티도 같은 방법으로 접근할 수 있다.
- 현재의 잔액에서 수수료를 뺀값을 얻는 코드와 새로운 값을 설정하는 코드는 다음과 같다.

## 🔸지연 저장 프로퍼티

- 프로퍼티를 초기화하는 여러 방법이 있는데, 가장 기본적인 방법은 다음과 같이 직접 할당하는 것이다.

 var myProperty = 10

- 다른 방법으로는 초기화 작업에서 프로퍼티에 값을 할당하는 것이다.

```swift
class MyClass{
	let title: String

init(title:String){
	self.title = title
}
}
```

- 좀더 복잡한 방법으로는 클로저를 이용하여 프로퍼티를 초기화할 수도 있다.

```swift
class MyClass{

	var myProperty: String = {
	var result = resourceIntensiveTask()
	result = processData(data:result)
	return result
}()
```

- 복잡한 클로저의 경우는 초기화 작업이 리소스와 시간을 많이 사용하게 될 수 있다.
- 클로저를 이용하여 선언하면 해당 프로퍼티가 코드 내에서 실제로 사용되는지와 상관없이 클래스의 인스턴스가 생성될 때마다 초기화 작업이 수행될 것이다.
- 예를 들어, 데이터베이스로부터 데이터를 가져오거나 사용자로부터 사용자 입력을 얻게 될 대, 실행 프로세스의 후반부 단계까지 프로퍼티에 값이 할당되었는지 모르게 되는 상황이 생길 수있다.
- 이러한 상황에서의 더 효율적인 방법은 프로퍼티를 최초로 접근할때만 초기화 작업을 하는 것이다.
- 다행히도 이 작업은 **lazy**로 프로퍼티를 선언하면 된다.

## 🔸self 사용하기

```swift
class MyClass {
	var mynumber = 1

func addTen(){
	self.myNumber += 10
}
}
```

- 객체지향 프로그래밍 언어에 익숙한 프로그래머라면 현재의 클래스 인스턴스에 속한 메서드나 프로퍼티를 가리킬 때 프로퍼티와 메서드 앞에 self를 붙이는 습관이 있을 것이다.
- swift 프로그래밍 언어 역시 그렇게 사용하기 위한 **self** 프로퍼티 타입을 제공한다.

![33.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cd450cc5-597f-441a-822e-6e866a8340db/33.png)

- swift로 프로그래밍 할때는 self를 사용할 필요가 없다.
- 왜냐하면 self 프로퍼티와 메서드에 대한 참조를 디폴트로 간주하기 때문이다.

- 대부분의 경우는 swift에서 self 는 선택적으로 사용된다.
- self를 사용해야 하는 상황은 프로퍼티나 메서드를 클로저 표현식 내에서 참조할 경우다.
- 예를 들어, 다음의 클로저 표현식에서는 반드시 self를 사용해야 한다.

```swift
document?.openWithCompletionHandler({(success:Bool) -> Void in
	if success{
		self.ubiquityURL = resultURL
}
})
```

- 또한, 함수의 매개변수가 클래스 프로퍼티와 동일한 이름을 가질 경우 코드의 모호성을 해결하기 위해 self를 사용
- Ex) 첫번째 print 구문은 myNumber 매개변수를 통해 함수에 전달된 값을 출력하겠지만,
- 두번째 print 구문은 myNumber라는 클래스 프로퍼티에 할당된 값 (여기서는 10)을 출력한다.
    
    ![35.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/352373b5-5913-4a55-a402-c26b2c94d397/35.png)
    
- self 사용여부는 프로그래머의 취향에 달렸다.
- 프로퍼티나 메서드를 참조할 때 self를 사용하기 좋아하는 프로그래머들도 자신이 원하는 방식으로 스위프트 코딩을 계속해갈 수 있다.
- 하지만 swift 프로그래밍 할때 self를 반드시 사용해야 하는 것은 아니다.

## 🔸프로토콜 이해하기

- 클래스가 구조적으로 올바르게 되기 위하여 swift 클래스가 반드시 따라야 할 특징 규칙은 기본적으로 없다.
- 하지만 , 다른 클래스와 함께 작업을 해야 할대는 특정 조건에 맞춰야 한다.
- iOS SDK의 다양한 프레임워크와 함께 동작하는 클래스를 만들때는 더욱 그러하다.
- 클래스가 충족해야 하는 최소한의 요구사항을 정의하는 규칙들의 집합을 **프로토콜**이라고 한다.
- 프로토콜은 **protocol**  키워드를 이용하여 선언되며, 클래스가 반드시 포함해야 하는 메서드와 프로퍼티를 정의한다.
- 어떤 클래스가 프로토콜을 채택했으나 모든 프로토콜의 요구사항을 충족하지 않는다면, 그 클래스가 해당 프로토콜을 다르지 않는다는 에러가 발생하게 된다.

- 다음의 프로토콜 선언부를 보면, 이 프로토콜을 채택하는 클래스는 이름의 읽을 ㅅ ㅜ있는 문자열 값에 대한 name 이라는 프로퍼티와 매개변수를 받지 않고 문자열 값을 반환하는 buildMessage() 메서드를 반드시 포함해야 한다.

![37.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0d07488e-46d5-4237-ae15-0d08e54461e4/37.png)

- 프로토콜을 준수하기 위해서 클래스는 다음과 같이 모든 조건을 충족해야 한다.

![38.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2357f767-b518-46a8-bd92-42c4ae964847/38.png)

## 🔸Activity

![39.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/21bb9139-91ab-4b00-8263-0c3c454a523a/39.png)

![40.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b88b3b0c-899a-40de-abe4-396755a9f957/40.png)

```swift
import Foundation

protocol Device {
    var name: String {get}
    var color : String {get set}
    func buildMemoText() -> String
}

class MyComputer : Device {
    //여러분의 구현 코드는 여기에...
    var name : String {
        get{
            return "MacBook Pro 2022"
        }
    }
    
    var color: String{
        get{
            return colors
        }
        set{
            colors = newValue + colors
        }
    }
    
    var colors = "grey"
    var kind: String = ""
    var dateOfpurchase: String = ""
    var price : Int = 0
    init(kind : String)
    {
        self.kind = kind
    }
    
    func displayComputer() -> (String, String, Int){
        return (kind,dateOfpurchase,price)
    }
    
    func buildMemoText() -> String {
        return "name : \(name), color: \(color)"
    }
}
    var myMac: MyComputer = MyComputer(kind:"MacBook")
    myMac.dateOfpurchase = "2022-04-01"
    myMac.price = 100
    print("information: \(myMac.displayComputer())")
    myMac.color = "Space"
    print(myMac.buildMemoText())
```
